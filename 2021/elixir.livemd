# Advent of Code - 2021

## Setup

```elixir
Mix.install([
  {:kino, "~> 0.4.1"}
])
```

## Day 1: Sonar Sweep

```elixir
input = Kino.Input.textarea("Input")
```

```elixir
Kino.Input.read(input)
|> String.split("\n", trim: true)
|> Enum.map(&String.to_integer(&1))
|> Enum.chunk_every(2, 1, :discard)
|> Enum.map(fn [x, y] -> y > x end)
|> Enum.count(fn x -> x end)
```

```elixir
Kino.Input.read(input)
|> String.split("\n", trim: true)
|> Enum.map(&String.to_integer(&1))
|> Enum.chunk_every(3, 1, :discard)
|> Enum.map(&Enum.sum(&1))
|> Enum.chunk_every(2, 1, :discard)
|> Enum.map(fn [x, y] -> y > x end)
|> Enum.count(fn x -> x end)
```

## Day 2: Dive!

```elixir
input = Kino.Input.textarea("Input")
```

```elixir
Kino.Input.read(input)
|> String.split("\n", trim: true)
|> Enum.map(&String.split(&1, " "))
|> Enum.split_with(fn [action, _] ->
  case action do
    "forward" -> true
    _ -> false
  end
end)
|> then(fn {l, r} ->
  {
    Enum.map(l, fn [_, v] -> String.to_integer(v) end),
    Enum.map(r, fn [action, v] ->
      case action do
        "up" -> String.to_integer(v) * -1
        "down" -> String.to_integer(v)
      end
    end)
  }
end)
|> then(fn {l, r} -> Enum.sum(l) * Enum.sum(r) end)
```

```elixir
Kino.Input.read(input)
|> String.split("\n", trim: true)
|> Enum.map(&String.split(&1, " "))
|> Enum.map(fn [action, v] ->
  v = String.to_integer(v)

  case action do
    "up" -> [0, -v, 0]
    "down" -> [0, v, 0]
    "forward" -> [v, 0, v]
  end
end)
|> Enum.reduce({0, 0, 0}, fn [h, a, d], {acc_h, acc_a, acc_d} ->
  {
    acc_h + h,
    acc_a + a,
    acc_d + d * (acc_a + a)
  }
end)
|> then(fn {x, _, y} -> x * y end)
```

## Day 3: Binary Diagnostic

```elixir
input = Kino.Input.textarea("Input")
```

```elixir
defmodule M do
  def calc(freq, func) do
    freq
    |> Enum.map(&func.(&1, fn r -> elem(r, 1) end))
    |> Enum.map(&elem(&1, 0))
    |> List.to_string()
    |> String.to_integer(2)
  end
end

Kino.Input.read(input)
|> String.split()
|> Enum.map(&String.to_charlist/1)
|> Enum.zip()
|> Enum.map(&Tuple.to_list/1)
|> Enum.map(&Enum.frequencies/1)
|> then(fn freq ->
  M.calc(freq, &Enum.max_by/2) * M.calc(freq, &Enum.min_by/2)
end)
```

```elixir
defmodule M do
  defp freq_bit(li, max_fn) do
    li
    |> Enum.frequencies()
    |> max_fn.()
    |> then(fn r -> elem(r, 0) end)
  end

  def filter(li, position, max_fn) do
    if length(li) == 1 do
      li
    else
      filter(do_filter(li, position, max_fn), position + 1, max_fn)
    end
  end

  defp do_filter(li, position, max_fn) do
    li
    |> Enum.zip()
    |> Enum.at(position)
    |> Tuple.to_list()
    |> freq_bit(max_fn)
    |> then(fn bit ->
      Enum.filter(li, fn l -> Enum.at(l, position) == bit end)
    end)
  end

  defp max(li) do
    Enum.max_by(
      li,
      fn r -> elem(r, 1) end,
      fn x, y -> x > y end
    )
  end

  defp min(li) do
    Enum.min_by(
      li,
      fn r -> elem(r, 1) end,
      fn x, y -> x <= y end
    )
  end

  def oxygen(li) do
    li
    |> filter(0, &max/1)
    |> Enum.at(0)
    |> List.to_string()
    |> String.to_integer(2)
  end

  def co2(li) do
    li
    |> filter(0, &min/1)
    |> Enum.at(0)
    |> List.to_string()
    |> String.to_integer(2)
  end
end

Kino.Input.read(input)
|> String.split()
|> Enum.map(&String.to_charlist/1)
|> then(&(M.oxygen(&1) * M.co2(&1)))
```

## Day 4: Giant Squid

```elixir
defmodule Parser do
  defp parse_numbers(s) do
    s
    |> String.split(",")
    |> Enum.map(&String.to_integer/1)
  end

  defp parse_boards(l) do
    l
    |> Enum.map(&String.split(&1, "\n", trim: true))
    |> Enum.map(fn r ->
      Enum.map(r, fn r ->
        r
        |> String.split()
        |> Enum.map(&String.to_integer/1)
      end)
    end)
  end

  def parse_input(input) do
    input
    |> String.split("\n\n", trim: true)
    |> then(fn r ->
      [first_line | rest_lines] = r
      {parse_numbers(first_line), parse_boards(rest_lines)}
    end)
  end
end

defmodule Bingo.BoardGrid do
  defstruct [:value, checked: false]

  def new(v, checked \\ false) do
    %__MODULE__{value: v, checked: checked}
  end
end

defmodule Bingo.BoardRow do
  defstruct [:grids]

  def new(l) do
    %__MODULE__{grids: Enum.map(l, &Bingo.BoardGrid.new/1)}
  end

  def input(self, number) do
    grids =
      self.grids
      |> Enum.map(fn grid ->
        if grid.value == number do
          %Bingo.BoardGrid{grid | checked: true}
        else
          grid
        end
      end)

    %__MODULE__{self | grids: grids}
  end

  def bingo(self) do
    self.grids
    |> Enum.all?(fn grid -> grid.checked end)
  end

  def unmarked_numbers(self) do
    self.grids
    |> Enum.filter(fn x -> not x.checked end)
    |> Enum.map(fn x -> x.value end)
  end
end

defmodule Bingo.Board do
  defstruct [:rows]

  def new(l) do
    %__MODULE__{rows: Enum.map(l, &Bingo.BoardRow.new/1)}
  end

  def input(self, number) do
    rows = self.rows |> Enum.map(fn row -> Bingo.BoardRow.input(row, number) end)
    %__MODULE__{self | rows: rows}
  end

  def cols(self) do
    self.rows
    |> Enum.map(fn row -> row.grids end)
    |> Enum.zip()
    |> Enum.map(fn col ->
      col
      |> Tuple.to_list()
      |> Enum.map(fn grid -> Bingo.BoardGrid.new(grid.value, grid.checked) end)
      |> then(fn grids -> %Bingo.BoardRow{grids: grids} end)
    end)
  end

  def bingo(self) do
    Enum.any?([
      self.rows |> Enum.any?(fn row -> Bingo.BoardRow.bingo(row) end),
      cols(self) |> Enum.any?(fn col -> Bingo.BoardRow.bingo(col) end)
    ])
  end

  def unmarked_numbers(self) do
    self.rows
    |> Enum.flat_map(fn row -> Bingo.BoardRow.unmarked_numbers(row) end)
  end

  # defimpl Inspect, for: Bingo.Board do
  #   import Inspect.Algebra

  #   def inspect(board, opts) do
  #     board.rows
  #       |> Enum.map(fn row -> Enum.map(row.grids, fn grid -> grid.checked end) end)
  #       |> inspect
  #   end
  # end
end

defmodule Bingo do
  defstruct boards: []

  def new(l) do
    %__MODULE__{boards: Enum.map(l, &Bingo.Board.new/1)}
  end

  def bingo(self) do
    self.boards
    |> Enum.filter(fn board -> Bingo.Board.bingo(board) end)
    |> then(fn l -> if(length(l) == 0, do: nil, else: l) end)
  end

  def process(self, number) when is_integer(number) do
    boards = self.boards |> Enum.map(fn board -> Bingo.Board.input(board, number) end)
    %__MODULE__{self | boards: boards}
  end

  def process(self, numbers) when is_list(numbers) do
    Enum.reduce_while(numbers, self, fn n, acc ->
      acc = process(acc, n)
      bingo_board = bingo(acc)

      if bingo_board do
        {:halt, {acc, bingo_board, n}}
      else
        {:cont, acc}
      end
    end)
  end

  def unmarked_numbers(self) do
    self.boards
    |> Enum.flat_map(fn board -> Bingo.Board.unmarked_numbers(board) end)
  end

  # def process(self, numbers) when is_list(numbers) do
  #   for n <- numbers do
  #     self = process(self, n)
  #   end

  #   self
  # end
end
```

```elixir
input = Kino.Input.textarea("Input")
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
Kino.Input.read(input)
|> Parser.parse_input()
|> then(fn {numbers, boards} ->
  Bingo.new(boards)
  |> Bingo.process(numbers)
  |> then(fn {_bingo, boards, number} ->
    Bingo.Board.unmarked_numbers(Enum.at(boards, 0)) |> Enum.sum() |> Kernel.*(number)
  end)
end)
```
